<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1">

		<title>Grapevine | .NET Embeddable Rest Server</title>

		<meta name="description" content="Grapevine is an embeddable REST server written is C# for the .NET platform, based on the HttpListener class. It also contains a powerful yet easy to use REST client.">
		<meta name="author" content="Scott Offen">

		<!-- missing favicon -->

		<link rel="stylesheet" href="/Grapevine/assets/css/bootstrap.min.css">
		<link rel="stylesheet" href="/Grapevine/assets/css/ie10-viewport-bug-workaround.css">
		<link rel="stylesheet" href="/Grapevine/assets/css/prism.min.css">
		<link rel="stylesheet" href="/Grapevine/assets/css/font-awesome.min.css">
		<link rel="stylesheet" href="/Grapevine/assets/css/styles.css">

		<!--
		<link rel="apple-touch-icon" href="/Grapevine/assets/img/apple-touch-icon.png">
		<link rel="apple-touch-icon" sizes="72x72" href="/Grapevine/assets/img/apple-touch-icon-72x72.png">
		<link rel="apple-touch-icon" sizes="114x114" href="/Grapevine/assets/img/apple-touch-icon-114x114.png">
		-->

		<!--[if lt IE 9]>
			<script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
			<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
		<![endif]-->
	</head>
	<body>
		<nav class="navbar navbar-default navbar-fixed-top">
			<div class="container">
				<div class="navbar-header">
					<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
						<span class="sr-only">Toggle navigation</span>
						<span class="icon-bar"></span>
						<span class="icon-bar"></span>
						<span class="icon-bar"></span>
					</button>
					<a class="navbar-brand" href="/Grapevine/">Grapevine</a>
				</div>
				<div id="navbar" class="navbar-collapse collapse">
					<div class="navbar-form navbar-left" role="search">
						<div class="form-group">
							<input id="search" type="search" class="form-control" placeholder="Search">
						</div>
					</div>
					<ul class="nav navbar-nav navbar-right">
						<!--
						<li class="dropdown">
							<a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Documentation <span class="caret"></span></a>
							<ul class="dropdown-menu">
								<li><a href="/Grapevine/rest_client">Rest Client</a></li>
								<li><a href="/Grapevine/rest_server">Rest Server</a></li>
								<li><a href="/Grapevine/misc">Miscellaneous</a></li>
								<li><a href="/Grapevine/about">About Grapevine</a></li>
							</ul>
						</li>
						-->
						<li><a href="https://github.com/sukona/Grapevine" class="text-muted pull-right"><i class="fa fa-github"></i> Fork on GitHub</a></li>
						<li><a href="https://gitter.im/sukona/Grapevine">Discuss on Gitter</a></li>
						<li><a href="https://github.com/sukona/Grapevine/blob/master/SUPPORT.md">Support</a></li>
					</ul>
				</div>
			</div>
		</nav>

		<div class="container">
			<div class="row">
				<div class="col-sm-12">
					<h2>Grapevine<br><span style="font-weight: lighter;" class="small text-muted">The embeddable, unopinionated minimalist rest framework for .NET</span></h2>
				</div>
			</div>
			<div class="row">
				<div class="col-sm-4 col-md-4">
					<h3>Embed</h3>
					<p>Use Grapevine to embed a restful web server in your application. With no dependency on IIS, you won't be bogged down by unnecessary ceremony to get your server up and running.</p>
				</div>

				<div class="col-sm-4 col-md-4">
					<h3>Web Apps</h3>
					<p>Use Grapevine to host your killer web app. Lose the cumbersome IIS and bloated System.Web, and say hello to an Express.js inspired router and optional route registration.</p>
				</div>

				<div class="col-sm-4 col-md-4">
					<h3>Client</h3>
					<p>Want to dialog with other restful services without depending on <i>another</i> library? Grapevine provides simple patterns and placeholders to help you consume rest resources easily and quickly.</p>
				</div>
			</div>
			<hr/>
			<div class="row">
				<div class="col-sm-12">
					<h2>Keeping It Simple<br><span style="font-weight: lighter;" class="small text-muted">Getting started with Grapevine</span></h2>
				</div>
			</div>
			<div class="row">
				<div class="col-sm-12">
					<p>Grapevine is founded on the principle of simplicity. In addition to being intentionally unopinionated - it doesn't want to get in the way of getting your work done - it's Grapevine's simple and declarative approach that sets it apart from other solutions. This guide will be focused on the simplest implementation of Grapevine - a console application.</p>

					<p>Create a new console application project and name it "GrapevineConsole". Add Grapevine in your project, then add the following code to your <code>Main()</code> method.</p>

					<pre>
						<code class="language-csharp">
						using (var server = new RestServer())
						{
							server.Start();
							Console.ReadLine();
							server.Stop();
						}
						</code>
					</pre>

					<p>When you run it, a console window appears with a blinking cursor, and stays there until you either hit Enter or close the program. If you open a web browser while the application is running to <a href="http://localhost:1234">http://localhost:1234</a>, you will see a very unhelpful page with the words <b>Not Found</b>.</p>
				</div>
			</div>
			<div class="row">
				<div class="col-sm-12">
					<h3>Logging To The Console</h3>
					<p>We can make this example a little more helpful by having Grapevine log out to the console what it's doing. Where reasonable, methods on objects in Grapevine are chainable, making it easy to tell the <code>RestServer</code> to write diagnostic information out to the console.</p>

					<pre>
						<code class="language-csharp">
						using (var server = new RestServer())
						{
							server.LogToConsole().Start();
							Console.ReadLine();
							server.Stop();
						}
						</code>
					</pre>

					<p>Run the application again, and the same console will appear, but this time with information on what's going on. Your console should display the following:</p>

<pre><code class="language-none">1/1/2016 12:30:15 PM   Trace   Scanning resources for routes...
1/1/2016 12:30:15 PM   Trace   Generating routes for assembly GrapevineConsole
1/1/2016 12:30:17 PM   Trace   Listening: http://localhost:1234/</code></pre>

					<p>This gives us a much better idea about what's going on. The <code>RestServer</code> is scanning for routes and not finding anything, so requests are returned having not found a route that responds to it.</p>
				</div>
			</div>
			<div class="row">
				<div class="col-sm-12">
					<h3>Creating Routes</h3>
					<p>So far, going to <a href="http://localhost:1234">http://localhost:1234</a> still shows the <b>Not Found</b> page. This is because we haven't defined any routes in our assembly. Routes are added by creating classes and methods in our project that meet specific criteria.</p>

					<p>For a given <code>Type</code> in an assembly to be automatically scanned for routes, the criteria it must meet are:</p>
					<ul>
						<li>It must be a public, reference-type class; <i>not an abstract class, struct, interface or value-type</i>.</li>
						<li>It must have the <code>[RestResource]</code> attribute on it.</li>
						<li>It must have a parameterless constructor.</li>
					</ul>

					<p>For methods in a class to be automatically registered as routes, the criteria the must meet are:</p>
					<ul>
						<li>It must have the <code>[RestRoute]</code> attribute on it.</li>
						<li>It must take a single argument of type <code>IHttpContext</code>.</li>
						<li>It must have a return value of type <code>IHttpContext</code>.</li>
					</ul>

					<div class="panel panel-info">
						<div class="panel-heading">
							<h3 class="panel-title">FYI</h3>
						</div>
						<div class="panel-body">
							While these are the same rules that previous versions of Grapevine tried to adhere to, the methods used to enforce those rules were a little bit different. Notice, for example, that you are no longer required to inherit from a specific base class, nor is the attributed class required to be sealed.
						</div>
					</div>

					<p>The <code>Router</code> on Grapevine's <code>RestServer</code> maintains an internal list of routes. While you can add routes to it manually, if the list is empty when the server is started, the <code>Router</code> will scan assemblies in your current <code>AppDomain</code> for routes. Assemblies are scanned in alphabetical order (skipping Grapevine and assemblies in the Global Assembly Cache), and each type in an assembly is likewise scanned in alphabetical order. In contrast, methods inside each type are discovered in the order the appear in the class itself.</p>

					<p>This is what is meant by <i><b>optional</b> route registration</i>. As long as your routes follow these conventions, they will be automatically registered with the router and incoming request will be routed to them, and you don't have to register them manually.</p>

					<p>Armed with this information, let's create our first routes.</p>

					<pre>
						<code class="language-csharp">
						[RestResource]
						public class TestResource
						{
							[RestRoute]
							public IHttpContext HelloWorld(IHttpContext context)
							{
								context.Response.SendResponse("Hello, world.");
								return context;
							}
						}
						</code>
					</pre>

					<p>When we start our server this time, and then go to <a href="http://localhost:1234">http://localhost:1234</a>, our message "Hello, world." shows up in the browser. Notice that we also see some different output in the console:</p>

<pre><code class="language-none">1/1/2016 12:30:15 PM   Trace   Scanning resources for routes...
1/1/2016 12:30:15 PM   Trace   Generating routes for assembly GrapevineConsole
1/1/2016 12:30:15 PM   Trace   Generating routes from type TestResource
1/1/2016 12:30:15 PM   Trace   Generated route ALL  > GrapevineConsole.TestResource.HelloWorld
1/1/2016 12:30:17 PM   Trace   Listening: http://localhost:1234/
1/1/2016 12:31:00 PM   Info    Routing Request  : 27ebe73f0fe5 - GET / has 1 routes
1/1/2016 12:31:00 PM   Trace   Route Invoked    : 27ebe73f0fe5 - 1/1 GrapevineConsole.TestResource.HelloWorld
1/1/2016 12:31:00 PM   Trace   Routing Complete : 27ebe73f0fe5 - 1 of 1 routes invoked</code></pre>

					<p>And now we can see that a route was registered, and a request sent to the server was routed to the route, which then responded to it.</p>

					<p>Let's define another route now, specifying the <code>HttpMethod</code> and <code>PathInfo</code> on the route, and see how they interact together.</p>

					<pre>
						<code class="language-csharp">
						[RestResource]
						public class TestResource
						{
							[RestRoute(HttpMethod = HttpMethod.GET, PathInfo = "/repeat")]
							public IHttpContext RepeatMe(IHttpContext context)
							{
								var word = context.Request.QueryString["word"] ?? "what?";
								context.Response.SendResponse(word);
								return context;
							}

							[RestRoute]
							public IHttpContext HelloWorld(IHttpContext context)
							{
								context.Response.SendResponse("Hello, world.");
								return context;
							}
						}
						</code>
					</pre>

					<p>Okay, lets run this and take a look at our console output. The first thing you should notice is that both routes were registered, but the new route was registered first. That's because it shows up first in the class itself. You should also get a better idea of what the pattern looks like when a route gets registered; namely <code>[HttpMethod] [PathInfo] > [MethodToExecute]</code>.</p>

					<p>The word <code>ALL</code> in the registration for our <code>HelloWorld</code> method means that, since we didn't specify which http method this route should handle, it will respond to routes with all http methods. The extra space where the <code>PathInfo</code> should be indicates that it will respond to requests from any path info. Compare that to the registration of the <code>RepeatMe</code> method, which will only respond to <code>GET</code> requests sent to <code>/repeat</code>.</p>


<pre><code class="language-none">1/1/2016 12:30:15 PM   Trace   Scanning resources for routes...
1/1/2016 12:30:15 PM   Trace   Generating routes for assembly GrapevineConsole
1/1/2016 12:30:15 PM   Trace   Generating routes from type TestResource
1/1/2016 12:30:15 PM   Trace   Generated route GET /repeat > GrapevineConsole.TestResource.RepeatMe
1/1/2016 12:30:15 PM   Trace   Generated route ALL  > GrapevineConsole.TestResource.HelloWorld
1/1/2016 12:30:17 PM   Trace   Listening: http://localhost:1234/</code></pre>

					<p>Open your browser again, and first go to <a href="http://localhost:1234/repeat?word=parrot">http://localhost:1234/repeat?word=parrot</a> and see the word "parrot" show up in the browser. Next go to <a href="http://localhost:1234">http://localhost:1234</a> and see "Hello, world." again. Then go back to the console window and see what has shown up there as a result of those requests.</p>

<pre><code class="language-none">1/1/2016 12:30:20 PM   Info    Routing Request  : 0b310261437c - GET /repeat has 2 routes
1/1/2016 12:30:20 PM   Trace   Route Invoked    : 0b310261437c - 1/2 GrapevineConsole.TestResource.RepeatMe
1/1/2016 12:30:20 PM   Trace   Routing Complete : 0b310261437c - 1 of 2 routes invoked
1/1/2016 12:30:25 PM   Info    Routing Request  : 095038b0deed - GET / has 1 routes
1/1/2016 12:30:25 PM   Trace   Route Invoked    : 095038b0deed - 1/1 GrapevineConsole.TestResource.HelloWorld
1/1/2016 12:30:25 PM   Trace   Routing Complete : 095038b0deed - 1 of 1 routes invoked</code></pre>

					<p>So, for each request we have a set of outputs. The <i>Routing Request</i> message is generated when the request is received by the router. In addition to the http method and path info, it tells us how many matching routes were found. The <i>Route Invoked</i> message is generated when a specific route has been invoked, and the <i>Routing Complete</i> message indicates that the router has finished invoking routes for a given request.</p>

					<p>Let me first draw your attention to the string of numbers and letters between the <code>:</code> and the <code>-</code> on each message. Because requests are handled in parallel on different threads, this unique identifier is used to keep track of which messages belong to the same request.</p>

					<p>Next, did you notice how it tells us that two routes were discovered for <code>GET /repeat</code>, but only one was executed? What's up with that?</p>

				</div>
			</div>
			<div class="row">
				<div class="col-sm-12">
					<h3>Responding To Requests</h3>
					<p>Routes are invoked on an incoming request until one of the routes responds to the request. By default, routing stops and subsequent routes are not invoked. Let's take advantage of that behaviour in this next example to execute several methods in a specific order.</p>

					<p>Let's replace the <code>RepeatMe</code> method with three new methods, <code>MeFirst</code>, <code>MeSecond</code> and <code>MeThird</code>, in that order, as shown below.</p>

					<pre>
						<code class="language-csharp">
						[RestResource]
						public class TestResource
						{
							[RestRoute(HttpMethod = HttpMethod.GET, PathInfo = "/inorder")]
							public IHttpContext MeFirst(IHttpContext context)
							{
								return context;
							}

							[RestRoute(HttpMethod = HttpMethod.GET, PathInfo = "/inorder")]
							public IHttpContext MeSecond(IHttpContext context)
							{
								return context;
							}

							[RestRoute(HttpMethod = HttpMethod.GET, PathInfo = "/inorder")]
							public IHttpContext MeThird(IHttpContext context)
							{
								return context;
							}

							[RestRoute]
							public IHttpContext HelloWorld(IHttpContext context)
							{
								context.Response.SendResponse("Hello, world.");
								return context;
							}
						}
						</code>
					</pre>

					<p>After starting our server and going to <a href="http://localhost:1234/inorder">http://localhost:1234/inorder</a>, we can  take a look at the messages generated in the console.</p>

<pre><code class="language-none">1/1/2016 12:30:15 PM   Info    Routing Request  : b194febe36f5 - GET /inorder has 4 routes
1/1/2016 12:30:15 PM   Trace   Route Invoked    : b194febe36f5 - 1/4 GrapevineConsole.TestResource.MeFirst
1/1/2016 12:30:15 PM   Trace   Route Invoked    : b194febe36f5 - 2/4 GrapevineConsole.TestResource.MeSecond
1/1/2016 12:30:15 PM   Trace   Route Invoked    : b194febe36f5 - 3/4 GrapevineConsole.TestResource.MeThird
1/1/2016 12:30:15 PM   Trace   Route Invoked    : b194febe36f5 - 4/4 GrapevineConsole.TestResource.HelloWorld
1/1/2016 12:30:15 PM   Trace   Routing Complete : b194febe36f5 - 4 of 4 routes invoked</code></pre>

					<p>Notice that <i>all four routes were invoked</i> until one of them - <code>HelloWorld</code> - responded to the request.</p>

					<div class="panel panel-danger">
						<div class="panel-heading">
							<h3 class="panel-title">Breaking Change!</h3>
						</div>
						<div class="panel-body">
							<p>Previous versions of Grapevine would only invoke the first matching route found. Now, routes will continue to be invoked until one of them responds or until all routes have been invoked. If none of the invoked routes responds, then a <b>Not Found</b> error is returned to the client.</p>
							<p>In addition, the methods for responding to a request are now methods on <code>context.Request</code>, not methods on the resource class that were inherited by an abstract base class.</p>
						</div>
					</div>

					<p>There are numerous overloads of the <code>SendResponse()</code> method that can be used to send different types of response.</p>
				</div>
			</div>
			<hr/>
			<div style="margin-bottom: 10px;" class="text-small text-muted">Copyright 2016 Scott Offen</div>
		</div>

		<!--[if lt IE 9]>
		<script src="/Grapevine/assets/js/jquery-1.12.4.min.js"></script>
		<![endif]-->
		<!--[if gte IE 9]><!-->
		<script src="/Grapevine/assets/js/jquery-2.2.4.min.js"></script>
		<!--<![endif]-->

		<script src="/Grapevine/assets/js/bootstrap.min.js"></script>
		<script src="/Grapevine/assets/js/prism.min.js"></script>

		<!-- [if IE 10]>
		<script src="/Grapevine/assets/js/ie10-viewport-bug-workaround.js"></script>
		<![endif]-->

		<!-- [if IE]>
		<script src="/Grapevine/assets/js/console.js"></script>
		<![endif]-->

		<script src="/Grapevine/assets/js/grapevine.min.js"></script>

		<script>
			(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
			ga('create', 'UA-35821423-3', 'auto');
			ga('send', 'pageview');
		</script>
	</body>
</html>
